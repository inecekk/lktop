#!/bin/bash
# lktop - Version 4.3.0 (9 Docker + 22 Processes Alignment)

# --- 1. æ ·å¼ä¸é¢œè‰² ---
B="\033[1m" D="\033[0;90m" W="\033[1;37m" G="\033[32m" Y="\033[33m" R="\033[31m" RES="\033[0m"
C1="${B}\033[38;5;196m" C2="${B}\033[38;5;208m" C3="${B}\033[38;5;226m" C4="${B}\033[38;5;118m" C5="${B}\033[38;5;81m"

# --- 2. æ ¸å¿ƒç®—æ³• ---
fmt_time_full() {
    local s=${1:-0}
    local y=$((s/31536000)) mn=$(( (s%31536000)/2592000 )) d=$(( (s%2592000)/86400 ))
    local h=$(( (s%86400)/3600 )) m=$(( (s%3600)/60 )) sec=$(( s%60 ))
    local res=""
    [ $y -gt 0 ] && res+="${y}å¹´"
    [ $mn -gt 0 ] && res+="${mn}æœˆ"
    [ $d -gt 0 ] && res+="${d}å¤© "
    printf "%s%02d:%02d:%02d" "$res" "$h" "$m" "$sec"
}

draw_bar() {
    local val=${1%.*}
    [ $val -gt 100 ] && val=100; [ $val -lt 0 ] && val=0
    local width=15 color=$G; [ $val -gt 50 ] && color=$Y; [ $val -gt 85 ] && color=$R
    local filled=$(( val * width / 100 )); local empty=$(( width - filled ))
    printf "${D}[${RES}${color}%s${D}%s]${RES}" "$(printf 'â– %.0s' $(seq 1 $filled 2>/dev/null))" "$(printf 'Â·%.0s' $(seq 1 $empty 2>/dev/null))"
}

get_metrics() {
    local stat1=$(grep '^cpu ' /proc/stat)
    sleep 0.2
    local stat2=$(grep '^cpu ' /proc/stat)
    CPU_USAGE=$(echo "$stat1 $stat2" | awk '{
        for(i=2;i<=11;i++) { t1+=$i; if(i<=4) u1+=$i }
        for(i=13;i<=22;i++) { t2+=$i; if(i<=15) u2+=$i }
        usage = (u2-u1)*100/(t2-t1);
        if (usage > 100) usage = 100; if (usage < 0) usage = 0;
        printf "%.1f", usage
    }')
    read t_mem u_mem < <(free -m | awk '/Mem:/ {print $2, $3}')
    MEM_P=$(awk "BEGIN {printf \"%.1f\", ($u_mem/$t_mem)*100}")
    LOAD=$(cat /proc/loadavg | cut -d' ' -f1-3)
    UP_SECONDS=$(cat /proc/uptime | awk '{print int($1)}')
}

# --- 3. æ¸²æŸ“ä¸»å¼•æ“ ---
clear; get_metrics; COLUMNS=$(tput cols)

printf "\n  ${C1}l${C2}k${C3}t${C4}o${C5}p${RES} ${W}SNAPSHOT${RES} ${D}â”‚ UP: $(fmt_time_full $UP_SECONDS)${RES}\n"
printf "  ${D}CPU  ${W}%5s%%${RES} $(draw_bar $CPU_USAGE)  " "$CPU_USAGE"
printf "${D}MEM  ${W}%5s%%${RES} $(draw_bar $MEM_P)  " "$MEM_P"
printf "${D}LOAD: ${Y}${LOAD}${RES}\n"

# Docker æ¨¡å— - Top 9
if command -v docker >/dev/null 2>&1; then
    D_STATS=$(docker stats --no-stream --format "{{.Name}}|{{.CPUPerc}}|{{.MemUsage}}|{{.NetIO}}" 2>/dev/null)
    if [[ -n "$D_STATS" ]]; then
        printf "\n  ${B}${W}ğŸ³ DOCKER CONTAINERS å®¹å™¨å ç”¨ (Top 9)${RES}\n"
        printf "  ${D}%-22s %-8s %-18s %-10s${RES}\n" "NAME åç§°" "CPU" "MEM å†…å­˜" "NET I/O"
        echo "$D_STATS" | sort -t'|' -k3 -hr | head -n 9 | while IFS='|' read -r name cpu mem net; do
            printf "  ${G}%-22.22s${RES} %-8s %-18s %-10s\n" "$name" "$cpu" "$mem" "$net"
        done
    fi
fi

# è¿›ç¨‹åˆ—è¡¨ - è°ƒæ•´ä¸º 22 ä¸ªè¿›ç¨‹
printf "\n  ${B}${D}%-4s %-9s %-22s %-12s %-10s${RES}\n" "ID" "PID" "PROCESS è¿›ç¨‹" "MEM å†…å­˜" "STATUS"
printf "  ${D}$(printf '%.sâ”€' $(seq 1 $((COLUMNS-6))))${RES}\n"

idx=1; declare -A pid_map
while read p cpu rss args; do
    pid_map[$idx]=$p
    mb=$(awk "BEGIN {printf \"%.1f\", $rss/1024}")
    cmd_name=$(basename -- "$(echo "$args" | awk '{print $1}')" 2>/dev/null || echo "$args" | cut -d' ' -f1)
    
    s_light="${G}â—${RES}"; [[ $(echo "$cpu > 25" | bc -l 2>/dev/null) -eq 1 ]] && s_light="\033[5;31mâ—${RES}"
    
    # é¢œè‰²è®¾ç½®ï¼šå‰ 7 ä¸ªé«˜äº®
    if [ $idx -le 7 ]; then
        case $((idx % 5)) in 1) c=$C1 ;; 2) c=$C2 ;; 3) c=$C3 ;; 4) c=$C4 ;; 0) c=$C5 ;; esac
    else
        c=$W
    fi
    
    printf "  ${c}%2d${RES}  %-9s ${B}${W}%-22.22s${RES} ${W}%8s MB${RES}   ${s_light} ${D}CPU:${G}%s%%${RES}\n" \
           "$idx" "$p" "$cmd_name" "$mb" "$cpu"
    ((idx++))
done < <(ps -eo pid,pcpu,rss,args --sort=-rss | head -n 23 | tail -n +2)

printf "  ${D}$(printf '%.sâ”€' $(seq 1 $((COLUMNS-6))))${RES}\n"
printf "\n  ${B}${W}âš¡ è¾“å…¥ ID ç»“æŸè¿›ç¨‹ / Enter é€€å‡º: ${RES}"; read -r tidx
if [[ -n "$tidx" && -n "${pid_map[$tidx]}" ]]; then
    kill -9 "${pid_map[$tidx]}" 2>/dev/null && exec "$0"
fi
