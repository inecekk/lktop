#!/bin/bash
# lktop - Version 4.7.0 (Layout Restructured & Bilingual)

# --- È¢úËâ≤‰∏éÊ†∑Âºè ---
B="\033[1m" D="\033[0;90m" W="\033[1;37m" G="\033[32m" Y="\033[33m" R="\033[31m" RES="\033[0m"
C1="${B}\033[38;5;196m" C2="${B}\033[38;5;208m" C3="${B}\033[38;5;226m" C4="${B}\033[38;5;118m" C5="${B}\033[38;5;81m"

# --- Â∑•ÂÖ∑ÂáΩÊï∞ ---
fmt_mem() {
    local kb=${1:-0}
    if (( kb < 1048576 )); then
        awk "BEGIN {printf \"%8.1f MB\", $kb/1024}"
    else
        awk "BEGIN {printf \"%8.2f GB\", $kb/1048576}"
    fi
}

draw_bar() {
    local val=$1; local int_val=${val%.*}
    int_val=${int_val:-0}
    local w=15 color=$G
    [ "$int_val" -gt 50 ] && color=$Y
    [ "$int_val" -gt 85 ] && color=$R
    local f=$(( int_val * w / 100 )); local e=$(( w - f ))
    printf "${D}[${RES}${color}%s${D}%s]${RES}" "$(printf '‚ñ†%.0s' $(seq 1 $f 2>/dev/null))" "$(printf '¬∑%.0s' $(seq 1 $e 2>/dev/null))"
}

get_metrics() {
    SGT_TIME=$(TZ="Asia/Singapore" date "+%Y-%m-%d %H:%M:%S")
    UP_SEC=$(awk '{print int($1)}' /proc/uptime)
    LOAD_VAL=$(cut -d' ' -f1-3 /proc/loadavg)
    TCP_CONN=$(ss -ant | grep -c 'ESTAB' || echo 0)
    DISK_P=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    
    # IO ËÆ°ÁÆó
    local io1=$(awk '{print $3,$7,$11}' /proc/diskstats | grep -E '^[v|s]da ' | head -1)
    sleep 0.1
    local io2=$(awk '{print $3,$7,$11}' /proc/diskstats | grep -E '^[v|s]da ' | head -1)
    IO_READ=$(echo "$io1 $io2" | awk '{printf "%.1f", ($5-$2)*512/1024/0.1}')
    IO_WRITE=$(echo "$io1 $io2" | awk '{printf "%.1f", ($6-$3)*512/1024/0.1}')

    # CPU ÈááÈõÜ
    local s1=$(grep '^cpu ' /proc/stat)
    sleep 0.1
    local s2=$(grep '^cpu ' /proc/stat)
    CPU_USAGE=$(echo "$s1 $s2" | awk '{u=$2+$3+$4; t=u+$5+$6+$7+$8; if(NR==1){u1=u;t1=t}else{usage=(u-u1)*100/(t-t1); printf "%.1f", (usage>0?usage:0)}}')
    CPU_USAGE=${CPU_USAGE:-0.0}
    
    read t_m u_m < <(free -k | awk '/Mem:/ {print $2, $3}')
    MEM_P=$(awk "BEGIN {printf \"%.1f\", ($u_m/$t_m)*100}")
}

# --- Ê∏≤ÊüìÈù¢Êùø ---
clear; get_metrics; COL=$(tput cols)

# È°∂ÈÉ®Ê†áÈ¢òÊ†è
UP_D=$((UP_SEC/86400)); UP_H=$(((UP_SEC%86400)/3600)); UP_M=$(((UP_SEC%3600)/60))
UP_STR="${UP_D}d ${UP_H}h ${UP_M}m"
printf "\n  ${C1}l${C2}k${C3}t${C4}o${C5}p${RES} ${W}v4.7.0${RES}  ${D}‚îÇ ËøêË°å/Uptime: ${W}%-12s${RES} ${D}‚îÇ Êñ∞Âä†Âù°/SGT: ${Y}%s${RES}\n" "$UP_STR" "$SGT_TIME"

# Á¨¨‰∏ÄÊéíÔºöCPU ‰∏é ÂÜÖÂ≠ò
printf "  ${D}CPU      ${W}%5s%%${RES} $(draw_bar $CPU_USAGE)    " "$CPU_USAGE"
printf "${D}ÂÜÖÂ≠ò/Mem  ${W}%5s%%${RES} $(draw_bar $MEM_P)\n" "$MEM_P"

# Á¨¨‰∫åÊéíÔºöÁ£ÅÁõò‰∏éË¥üËΩΩ (ÂàÜÂ±Ç‰ºòÂåñ)
printf "  ${D}Á£ÅÁõò/Disk ${W}%5s%%${RES} $(draw_bar $DISK_P)    " "$DISK_P"
printf "${D}Ë¥üËΩΩ/Load ${Y}%s${RES}\n" "$LOAD_VAL"

# Á¨¨‰∏âÊéíÔºöIO‰∏éÁΩëÁªú
printf "  ${D}TCPËøûÊé•/Conn: ${W}%-6s${RES} ${D}‚îÇ Read: ${G}%-8s KB/s${RES} ${D}‚îÇ Write: ${R}%-8s KB/s${RES}\n" "$TCP_CONN" "$IO_READ" "$IO_WRITE"

# Docker ÊùøÂùó
if command -v docker >&/dev/null; then
    D_STATS=$(docker stats --no-stream --format "{{.Name}}|{{.CPUPerc}}|{{.MemUsage}}|{{.NetIO}}" 2>/dev/null)
    if [[ -n "$D_STATS" ]]; then
        printf "\n  ${B}${W}üê≥ DOCKER ÂÆπÂô®/Containers (Top 9)${RES}\n"
        printf "  ${D}%-22s %-8s %-18s %-15s${RES}\n" "NAME" "CPU" "MEM" "NET I/O"
        echo "$D_STATS" | sort -t'|' -k3 -hr | head -n 9 | while IFS='|' read -r name cpu mem net; do
            printf "  ${G}%-22.22s${RES} %-8s %-18s %-15s\n" "$name" "$cpu" "$mem" "$net"
        done
    fi
fi

# ËøõÁ®ãÈù¢Êùø
printf "\n  ${B}${D}%-3s %-8s %-25s %-12s %-8s${RES}\n" "ID" "PID" "ËøõÁ®ã/Process" "ÂÜÖÂ≠ò/Mem" "Áä∂ÊÄÅ/Status"
printf "  ${D}$(printf '%.s‚îÄ' $(seq 1 $((COL-10))))${RES}\n"

idx=1; declare -A pid_map
while read p cpu rss args; do
    pid_map[$idx]=$p
    mem_fmt=$(fmt_mem $rss)
    cmd=$(basename -- "$(echo "$args" | cut -d' ' -f1)" 2>/dev/null | cut -c1-25)
    
    p_cpu=${cpu%.*}; p_cpu=${p_cpu:-0}
    c_color=$G; [ "$p_cpu" -gt 20 ] && c_color=$Y; [ "$p_cpu" -gt 50 ] && c_color=$R
    
    case $((idx % 5)) in 1) c=$C1 ;; 2) c=$C2 ;; 3) c=$C3 ;; 4) c=$C4 ;; 0) c=$C5 ;; esac
    [ $idx -gt 7 ] && c=$W

    printf "  ${c}%2d${RES} ${D}%-8s${RES} ${B}${W}%-25.25s${RES} %10s  ${c_color}‚óè${RES} ${D}%s%%${RES}\n" \
           "$idx" "$p" "$cmd" "$mem_fmt" "$cpu"
    ((idx++))
done < <(ps -eo pid,pcpu,rss,args --sort=-rss | head -n 22 | tail -n +2)

printf "  ${D}$(printf '%.s‚îÄ' $(seq 1 $((COL-10))))${RES}\n"
printf "\n  ${B}${W}‚ö° ËæìÂÖ• ID ÁªìÊùüËøõÁ®ã (Kill ID) / Enter ÈÄÄÂá∫: ${RES}"; read -r tidx
if [[ -n "$tidx" && -n "${pid_map[$tidx]}" ]]; then
    kill -9 "${pid_map[$tidx]}" 2>/dev/null && exec "$0"
fi
